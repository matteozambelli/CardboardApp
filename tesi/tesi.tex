% !TeX spellcheck = de_DE
%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt,a4paper,twoside, italian, openright]{book}
\usepackage[latin1]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage[left=3.00cm, right=3.00cm, top=3.00cm, bottom=3.00cm]{geometry}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{emptypage}
\usepackage{verbatim}
\usepackage[usenames,dvipsnames]{xcolor}
%inserire i link senza colorarli o riquadrarli:
\usepackage{hyperref}
\hypersetup{
	colorlinks=false,
	allbordercolors=White,
}
%elenchi con lettere:
\usepackage{enumerate}
% stili per inserire codice
\usepackage{listings}
\usepackage{caption}

\lstdefinestyle{numeri}{
	numbers=left, % where to put the line-numbers
	numberstyle=\tiny\color{Black} % the style that is used for the line-numbers
	%stepnumber=2, % the step between two line-numbers
	%numbersep=10pt, % how far the line-numbers are from the code
}
\lstdefinestyle{stiliComuni}{
	frame=single, % adds a frame around the code
	basicstyle={\normalsize\ttfamily},
	backgroundcolor=\color{black!5!white}, % choose the background color;
	showstringspaces=false, % underline spaces within strings only
	showspaces=false, % show spaces everywhere adding particular underscores		
	keepspaces=true, % keeps spaces in text 
	tabsize=2, % sets default tabsize to 2 spaces
	breaklines=true, % sets automatic line breaking
	showtabs=false,
	captionpos=b % sets the caption-position to bottom
}

%stile codice xml
\lstdefinelanguage{XML}{
	otherkeywords={policy, signer, default, package, seinfo},
	morecomment=[s]{<!--}{-->}
}
%linguaggio e stile policy
\lstdefinelanguage{Policy}{
	keywords={isSystemServer,user,domain,type,seinfo, typealias, allow, neverallow}
	%morecomment=[l]{#}
	%moreidentifiers={},
	%identifierstyle=\color{MidnightBlue},	
}
\lstset{
	frame=single,
	basicstyle={\normalsize\ttfamily},
	stringstyle=\color{YellowOrange},
	commentstyle=\color{OliveGreen},
	keywordstyle=\color{RubineRed},
	identifierstyle=\color{MidnightBlue},
	style=numeri,
	style=stiliComuni
}

\usepackage{pdfpages}
%per scrivere tag xml
\newcommand*{\xml}[1]{\texttt{<#1>}}

%interlinea 1.5
\onehalfspacing

%numeri di pagina dispari a dx e pari a sx nel piè di pagina
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[LE,RO]{\thepage}
\fancypagestyle{plain}{\fancyfoot[RO,LE]{\thepage}}



\author{Fabio Terzi and Matteo Zambelli}
\title{A Low Cost virtual reality game for amblyopia}


\renewcommand{\baselinestretch}{1.5} 
\newcommand{\virgolette}[1]{``#1''}
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\author{Fabio Terzi, Matteo Zambelli} % Your name

\begin{document}

%----------------------------------------------------------------------------------------
%	Ringraziamenti
%----------------------------------------------------------------------------------------	
	
\chapter*{}
\thispagestyle{empty}
	\vspace{\fill}
	\begin{flushright}
		Ringraziamo il Professor Angelo Gargantini per i preziosi insegnamenti, inoltre vogliamo ringraziare le nostre famiglie per il sostegno ed il grande aiuto.\\ 
		\textit{Fabio e Matteo}
		
	\end{flushright}
	
\thispagestyle{empty}	
\tableofcontents % l'indice

%----------------------------------------------------------------------------------------
%	PARTE I
%----------------------------------------------------------------------------------------
\part{Descrizione del contesto}
%----------------------------------------------------------------------------------------
%	introduzione
%----------------------------------------------------------------------------------------


\chapter{Introduzione}

In questo primo capitolo viene spiegato di cosa tratta il progetto 3D4Amb, del quale fa parte questo lavoro (\ref{3d4amb}) e qual è l'obiettivo di questa tesi (\ref{obiettivo}).

\section{Il progetto 3D4Amb}\label{3d4amb}
Il progetto 3D4Amb mira a sviluppare un sistema basato sul 3D per la diagnosi e il trattamento dell'ambliopia nei bambini piccoli.\\
Sfrutta la tecnologia 3D active shutter per garantire una visione binoculare, cioè per mostrare immagini diverse all'occhio normale e all'occhio pigro. Essa dovrebbe consentire una facile diagnosi dell'ambliopia e il suo trattamento per mezzo di giochi interattivi e attività di intrattenimento. Non dovrebbe soffrire dei problemi del trattamento classico dell'occlusione, è adatto ad un uso domestico, e potrebbe, almeno in parte, sostituire l'occlusione dell'occhio normale.\\                           
L'obiettivo principale di questo progetto di ricerca, denominato 3D4Amb, è di sviluppare un sistema per la diagnosi e il trattamento di ambliopia, basata sulla visione binoculare in modo accessibile. Con il termine accessibile si intende: poco costoso, user friendly, adatto per uso domestico e facilmente estendibile.\\
Tutte le informazioni sul progetto sono reperibili sul sito: http://3d4amb.unibg.it/
Car Racing Cardboard è un'applicazine per la piattaforma Android, il suo scopo è curare una patologia come l'ambliopia attraverso un gioco, in modo tale da far divertire il paziente ed allo stesso tempo sottoporlo al trattamento per la cura della sua malattia.

\section{Obiettivo}\label{obiettivo}
L'obiettivo di fonndo era quello di un \textbf{upgrade} della tesi triennale, dove era stato fatto un restyling di un videogioco desktop, chiamato Space Invaders \footnote{http://3d4amb.unibg.it/software/spaceinvaders.it.html}. \\
Nel 2013 provare il tipo di trattamento proposta da 3D4Amb avrebbe implicato l'acquisto di una scheda grafica 3D e di un monitor 3D.\\
Oggi con Car Racing Cardboard, è sufficiente acquistare un visore 3D come Google Cardboard (reperibile a circa 10\$ online), praticamente tutti possiedono uno smartphone,
quindi la terapia \virgolette{mnobile} proposta da 3D4Amb è in grado di raccogliere un bacino d'utenza molto più ampio.\\
Il fulcro di questa tesi è l'applicazione Car Racing Cardboard, nel corso di questo documento verrà analizzata sia a livello logico che a livello di implementazione.
%----------------------------------------------------------------------------------------
%	l'ambliopia
%----------------------------------------------------------------------------------------

\chapter{L'Ambliopia}

In questo secondo capitolo viene spiegato il l'ambito nel quale opera questa tesi (\ref{il_disturbo}), quali sono i tipi di trattamento al momento disponibili (\ref{trattamenti}) e la nuova tipologia di trattamento proposta dal progetto 3D4Amb (\ref{idea_3D4Amb}).

\section{Il disturbo}\label{il_disturbo}
L'ambliopia è una condizione di ridotta acuità visiva mono o bilaterale e si manifesta indipendentemente da causa organica. È dovuta ad una inadeguata stimolazione visiva
durante il periodo plastico del sistema visivo, ossia il periodo che va dalla nascita fino ai sette anni.\\
Il soggetto in cui è presente l'ambliopia soffre di un alterazione della visione dello spazio: le immagini che provengono dagli occhi non vengono correttamente rielaborate all'interno del cervello. Questo causa una scorretta comprensione dello spazio che lo circonda e causa una percezione scorretta della profondità, dei movimenti e dei contrasti.
È presente nel 2-4\% della popolazione, la sua incidenza è più elevata in associazione con alcune condizioni quali prematurità, sindrome di Down, patologia neurologica e familiarità per ambliopia o strabismo. Spesso le persone non si accorgono nemmeno di esserne affette fino ai 20-30 anni, per questo è fondamentale la diagnosi.\\
Può colpire i bambini dalla nascita fino ai 7 anni, età in cui il sistema visivo raggiunge la sua maturità. Durante questo periodo iniziale l'ambliopia può essere trattata e prevenuta, mentre superata questa fase l'istaurazione della malattia diventa impossibile, ma, nel caso fosse presente, essa risulta irreversibile. L'ambliopia funzionale deve essere distinta dall'ambliopia organica, la quale è un impoverimento della visione, causata da anomalie strutturali dell' occhio o del cervello, che sono indipendenti dagli input sensoriali.\\
L'ambliopia funzionale è reversibile se trattata con la stimolazione visiva adeguata, mentre quella organica non subisce alcun beneficio da una stimolazione visiva.
Il videogame di rebalance ha quindi effetto solo sull'ambliopia funzionale e non su quella organica.
\newpage
\section{Trattamenti}\label{trattamenti}
Il trattamento precoce dell'ambliopia è fondamentale per ottenere buoni risultati, la correzione oculare avviene in diversi modi:

\subsection{Occlusione}
La terapia occlusiva si basa sulla copertura dell'occhio sano per stimolare l'occhio ambliope. Solitamente nei pazienti affetti anche da strabismo l'occlusione avviene a tempo pieno; tuttavia l'occlusione  a tempo pieno, o occlusione totale, può causare un ambliopia inversa nei soggetti sotto i 4-5 anni. Per evitare l'insorgere di questo ulteriore problema, la condizione dell'ambliopia deve essere monitorata ogni settimana per l'età del bambino. Per esempio, un bambino di due anni va monitorato ogni due settimane, uno di tre ogni tre settimane. Nel caso in cui venga riscontrato che il paziente non sopporta un'occlusione totale si applica un'occlusione parziale, ossia solo qualche ora al giorno.

\subsection{Penalizzazione ottica}
Attuata con filtri di Bangerter (lenti con gradi diversi di opacizzazione, a seconda della entità della penalizzazione che si vuole attuare) o con  lenti più forti o più deboli poste davanti all'occhio sano per costringere quello malato a lavorare; come l'occlusione parziale, viene attuata o per coloro che  necessitano di una occlusione ''morbida'' o come terapia di mantenimento.

\subsection{Penalizzazione farmacologica}
Viene effettuata con un collirio cicloplegico instillato nell' occhio sano per escluderlo dal processo di visione e costringere quello malato a lavorare.

\subsection{Settorizzazione}
Consiste nella copertura di parte del campo visivo dell' occhio sano con pellicole adesive traslucide sugli occhiali. \\
Per il trattamento dell'ambliopia sono stati proposti anche degli stimolatori visivi di tipo elettrico (trattamento CAM-Cambridge Stimulator e trattamento Flicker): vengono inviati stimoli luminosi di vario tipo sulla retina dell'occhio ambliope, forzandolo  a trasmettere l'impulso luminoso al cervello, e riattivando così i canali "impigriti" dall'ambliopia. L'efficacia di queste metodiche è ancora oggi molto dibattuta.  Recentemente si stanno utilizzando farmaci neuroprotettivi come sostegno alla terapia occlusiva: studi recenti indicano che in questo modo viene potenziato l'effetto della terapia occlusiva e viene più facilmente stabilizzato il miglioramento della funzione visiva.
\newpage
\section{L'idea di 3D4Amb}\label{idea_3D4Amb}
3D4Amb ha ideato un sistema basato sulle tecnologie 3D per consentire la visione binoculare. L'uso classico di un sistema 3D è quello di fornire ai due occhi diverse immagini della stessa scena con angoli di visualizzazione leggermente sfalsati che corrispondono ai diversi punti di vista dell' occhio destro e sinistro. Questa visione produce un'illusione di profondità della scena ed è la base della realtà virtuale.\\                                                         
Il principio primario del sistema è che all' occhio ambliope (o occhio pigro) e all'occhio normale sono mostrate due immagini differenti ma correlate. Questo principio può essere utilizzato nella pratica per il trattamento di ambliopia, andando a mostrare all'occhio ambliope la parte più interessante dei frame della clip o del gioco, mentre all'occhio non ambliope (o buono) viene mostrata la parte meno interessante.\\
Il contenuto da mostrare al paziente (gioco o immagine) viene diviso da 3D4Amb in due parti, una per l'occhio destro (occhio ambliope, Figura ~\ref{idea 3D4Amb}) e una per l'occhio sinistro (occhio buono, Figura ~\ref{idea 3D4Amb}). Il software 3D4Amb deciderà cosa inviare ad entrambi gli occhi a seconda del tipo di trattamento suggerito dal medico. Si noti che l'occhio pigro del bambino è più stimolato a lavorare, ma l'occhio sano non è ''patchato''. Il cervello del paziente ha il compito di unire le due immagini per visualizzare il frame completo con successo ed eseguire correttamente operazioni semplici in caso di gioco interattivo. Per assicurarsi che il paziente possa unire le due immagini sono presenti un numero significativo di elementi comuni ad entrambe le immagini. Notare che il frame finale è una rappresentazione bidimensionale in quanto l'obiettivo è quello di non stimolare la visione stereo del paziente (almeno inizialmente).\cite{tesiTZ}


\begin{figure}[t]
	\centering
	\includegraphics[width=\columnwidth]{immagini/3D4Amb_sys.png}
	\caption{La tecnologia di 3D4Amb \label{idea 3D4Amb}}
\end{figure}

%----------------------------------------------------------------------------------------
%	la tecnlogia per il trattamento
%----------------------------------------------------------------------------------------
\chapter{La tecnologia per il trattamento}
In questo terzo capitolo viene spiegata la scelta del sistema operativo dell'applicazione realizzata e l'ambiente di sviluppo utilizzato (\ref{SO_ADS}), inoltre il capitolo contiene la descrizione al visore 3D \virgolette{ideale}con il quale interagisce l'applicazione (\ref{sectionGC}).

\section{Sistema operativo ed ambiente di sviluppo}\label{SO_ADS}
L'applicazione è stata progettata e sviluppata per il mondo Android. I software utilizzati per l'implementazione sono stati:
\begin{itemize}
	\item L'ultima versione del JDK, il kit di sviluppo per la tradizionale programmazione Java, reperibile dal sito Oracle\footnote{http://www.oracle.com/technetwork/java/javase/downloads/index.html} .
	\item L'IDE (ambiente di sviluppo integrato) Android Studio, alternativa fresca e promettente ad Eclipse. La sua installazione include il pacchetto di strumenti Android SDK, il quale è costituito da programmi, emulatori e piattaforme per ogni versione di Android. La sua composizione inoltre non è immutabile, ma viene gestita tramite il programma Android SDK Manager, avviabile dall'IDE, grazie al quale siamo stati in grado di profilare le piattaforme e gli strumenti presenti nel SDK nella maniera più congeniale al nostro lavoro.
	
\end{itemize}

In particolare si è deciso che il requisito minimo che deve possedere lo smartphone dell'utente che utilizza l'applicazione sia un livello di API(Application Programming Interface) 15, ovvero dal sistema operativo Android 4.0.3 \footnote{(ICE\_CREAM\_SANDWICH\_MR1)} in poi.
\subsection{Perchè Android}La scelta di sviluppare l'applicazione per il sistema operativo Android, anzichè ad esempio per iOS o Windows Phone, è figlia delle seguenti riflessioni:
Innanzitutto il sistema Android sta dilagando. Non è più solo questione di smartphone o tablet. Si sta imponendo come sistema operativo in grado di animare qualsiasi dispositivo più o meno mobile tanto da apparire, in prospettiva non troppo futuristica, una presenza sempre più costante nel nostro quotidiano. Gli è stata inoltre attribuita la più veloce diffusione mai vista per un sistema operativo mobile. Gran parte del merito è dovuto alle radici ben salde nel mondo open source. Il sistema operativo Android, infatti, è figlio di Linux, ed ha attirato l'interesse di tanti sviluppatori  che per anni si sono stretti intorno ai grandi bacini del software libero. Accoglie inoltre in sé tutto il meglio di quanto è stato ideato per supportare lo sviluppo del web, desktop e mobile sia in termini di pattern progettuali che di librerie software. Per decretare un successo tanto ampio è necessario che ci sia anche un forte riscontro di pubblico. Sicuramente un qualcosa che ha contraddistinto questo sistema è stata la sua adozione da parte di dispositivi molto diversi tra loro, non solo per tipologia (smartphone piuttosto che tablet), ma soprattutto per fasce di prezzo, da poche decine di euro fino a  cifre piuttosto significative. 
Ciò ne ha permesso una diffusione molto diverficata trasversalmente alle diverse categorie sociali, ma ha causato di riflesso una frammentazione notevole dello scenario applicativo costringendo gli sviluppatori ad una particolare cura degli aspetti di adattamento alle caratteristiche del dispositivo ospite. Proprio in questo, Android ha dimostrato la sua grande modernità offrendo tutto il supporto necessario per permettere all'applicazione in esecuzione di adeguarsi ad ogni circostanza.\\
Parlando di numeri, Android domina fra gli smartphone con una quota di mercato dell' 84,7\%. E' il dato principale che emerge dall' analisi della società di ricerca \textit{Idc} sul mercato dei cellulari. Il sistema operativo mobile di Google, a differenza di quello di Apple, è presente su decine di modelli di cellulari di marche diverse e domina il mercato lasciando alla \virgolette{Mela} l'11,7\% di share \cite{percentualeSmartphone}.
\subsection{Perchè Android Studio}\label{android_studio}
Dopo aver scelto per quale sistema operativo sviluppare, un'altra importante scelta è stata quella di identificare l'IDE più adatto alle nostre esigenze.
Android Studio è un' alternativa giovane ma molto promettente rispetto ad Eclipse. Esso è sponsorizzato direttamente da Google e pensato appositamente per Android. Gli elementi di Android Studio che spiccano maggiormente sono:
\begin{itemize}
	\item l'utilizzo di Gradle come strumento di build automation, atto quindi ad accompagnare lo sviluppatore nelle fasi di build, sviluppo, test e pubblicazione della propria app;
	\item disponibilità di un gran numero di template per la realizzazione di applicazioni già in linea con i più comuni pattern progettuali;
	\item editor grafico per la realizzazione di layout, molto pratico e dotato di un ottimo strumento di anteprima in grado di mostrare l'aspetto finale dell' interfaccia che si sta realizzando in una molteplicità di configurazioni (tablet e smartphone di vario tipo).
\end{itemize}

\begin{figure}[ht]
	\centering
	\includegraphics[width=50mm]{immagini/android-logo.png}
	\caption{Android Logo}
	\label{fig:android-logo}
\end{figure}
\newpage
\section{Google cardboard} \label{sectionGC}
Google cardboard è una piattaforma per la realtà virtuale sviluppata da Google. Creato da  David Coz e Damien Henry, due ingegneri della Google, nel Google Cultural Institute  a Parigi nel loro 20\%  \virgolette{Innovation Time Off} \cite{GCfb}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=\columnwidth]{immagini/Google-Cardboard.jpg}
	\caption{Google Cardboard}\label{googlecardboard}
\end{figure}

Introdotto nel 2014 al \virgolette{Google I/O developers conference for Android device}, è formato da un cartone ripiegabile e due lenti, l'utente deve inserirci lo smartphone (Figura ~\ref{googlecardboard}). Questo sistema consente una visione stereoscopica, funziona con differenti smartphone e può essere facilmente usato dai bambini.\\
Google cardboard non consente un' esperienza immersiva come Oculus rift, il quale necessita però di un PC collegato (ed è ancora in fase di sviluppo), ma è un modo facile ed economico per provare l'esperienza della realtà virtuale, inoltre la maggior parte delle applicazioni sono reperibili gratuitamente.
\linebreak
\textbf{Esistono rischi per la salute?}\\
Ad oggi non esistono evidenze scientifiche certe e rilevanti a supporto della tesi secondo cui le tecnologie 3D siano responsabili (o corresponsabili) della patogenesi di disturbi e difetti a carico dell'apparato della vista.\\
Tuttavia, è importante notare che l'assenza di prove a sostegno della tesi non implica la sua totale infondatezza, cioè in altre parole almeno per il momento non siamo in grado di mettere in relazione con certezza i due elementi.

	


%----------------------------------------------------------------------------------------
%	PARTE II
%----------------------------------------------------------------------------------------
\part{Panoramica sull'applicazione}
%----------------------------------------------------------------------------------------
%	l'applicazione
%----------------------------------------------------------------------------------------

\chapter{Car Racing Cardboard: l'applicazione}
Questo capitolo contiene la descrizione del principio di tratatamento del gioco (\ref{principio}), la spiegazione degli obiettivi del gioco (\ref{il_gioco}), e una giuda all'utilizzo dell'applicazione (\ref{guida}).

\section{Il principio del trattamento tramite il gioco}\label{principio}
L' applicazione sviluppata in questo progetto di tesi, punta a sfruttare le potenzialità del Google Cardboard per correggere il disturbo dovuto all'ambliopia. Fino ad ora, il trattamento standard consolidato per la cura della malattia è stato l'occlusione visiva.
Questa tecnica può però presentare alcuni limiti: 
\begin{itemize}
	\item in primo luogo la compliance (adesione del paziente alla terapia) è un fattore limitante da non trascurare, soprattutto quando la profondità dell'ambliopia richiede tempi lunghi di trattamento;
	\item Inoltre, l'occlusione è gravata dalla tendenza alla perdita di efficacia nel breve periodo. Infatti fino al 50\% dei benefici ottenuti vengono persi, se i risultati funzionali non sono stati resi stabili, prolungando il trattamento per un tempo sufficientemente lungo, dopo che si è registrato il miglioramento del visus.
\end{itemize}

Probabilmente la tendenza alla perdita di effetto è dovuta, almeno in parte, al fatto che l'occlusione non affronta un altro importante aspetto della terapia dell'ambliopia, cioè la stimolazione diretta dell'occhio con il deficit visivo. Sulla base di questo, si è quindi pensato di realizzare un gioco interattivo che punti alla cura dell'occhio ampliope in modo più coinvolgente.
Grazie quindi all'accessibilità dei Google Cardboard, all' evoluzione del mondo Android ed all'intrattenimento volontario ed intrinsecamente motivato dato dal gioco, è stato possibile creare un metodo di cura innovativo.
\begin{figure}[!ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/child_cardboard}
	\caption{Interactive game scene}
	\label{fig:child_cardboard}
\end{figure}
\newpage
\section{Il gioco}\label{il_gioco}
\subsection{Obiettivo}
L' applicazione Car Racing Cardboard consiste in un gioco il cui obiettivo è quello di ottenere il maggior punteggio possibile. L'utente ha la possibilità di manovrare un veicolo attraverso tre corsie. Il punteggio del gameplayer incrementa ogni volta che si evita un ostacolo, costituito dalle macchine che pervengono nella nostra direzione sulle tre corsie. Inizialmente la posizione del veicolo controllato dall'utente è nella corsia centrale, ma non appena inizia il gioco, si ha la possibilità di spostarsi a destra o a sinistra. Lo spostamento del veicolo viene gestito tramite un dispositivo bluetooth collegato allo smartphone o tramite degli auricolari aventi i pulsanti UP, DOWN e PLAY. Oltre al punteggio, esistono altre due variabili dipendenti dal comportamento dell'utente: una che conteggia le vite a disposizione ed una che indica il livello raggiunto. Inizialmente il gameplayer ha a disposizione un totale di tre vite, le quali decrementano nel momento in cui avviene una colluttazione con una macchina proveniente dal verso opposto. Il livelli inoltre incrementano col passare del tempo. La difficoltà del gioco, caratterizzata dal numero e dalla velocità dei nemici, incrementa con l'aumentare dei livelli.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/game}
	\caption{una scena del gioco}
	\label{fig:game}
\end{figure}

\subsection{Doppia Viewport}
Come si può vedere dall'immagine 5.2, l'applicazione viene realizzata renderizzando sullo smartphone dell'utente una doppia Viewport. Questo sdoppiamento, grazie alla tecnologia offerta dal Google Cardboard, permette all'utente una visione stereoscopica del gioco. Le due Viewport sono inoltre fondamentali per il principio di funzionamento della nostra applicazione. Infatti, grazie ad esse è possibile trattare in modo differente l'occhio sinistro dall'occhio destro, e più specificatamente l'occhio ambliope dall'occhio sano. Prima dell'inizio del gioco vero e proprio, l'applicazione da la possibilità di scegliere l'occhio pigro:

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/chooselazyeye_left}
	\caption{scelta dell'occhio pigro}
	\label{fig:chooselazyeye_left}
\end{figure}

In questo modo si da all'applicazione l'opportunità di trattare l'occhio pigro in modo da svilupparne la visione. In particolare l'applicazione andrà a penalizzare l'occhio sano riducendo l'opacità di alcuni elementi che caratterizzano la Viewport come ad esempio i veicoli nemici o il paesaggio, in modo da stimolare e sforzare l'occhio pigro ad allenarsi. La penalizzazione avviene in modo dinamico ed è la chiave della cura. Essa aumenta con l'aumentare dello score e dei livelli raggiunti dall'utente. 

\newpage
\section{Guida all'utilizzo}\label{guida}

Dopo aver scaricato l'applicazione da Google Play Store \footnote{https://play.google.com/store/apps/details?id=it.unibg.p3d4amb.carracingcarboard\&hl=it}
è possibile friure dei contenuti di Car Racing Cardboard.
Connettere quindi lo smartphone agli auricolari, ma aspettare ad inserirlo nel visore 3D.
La schermata di avvio è la seguente (Figura \ref*{login_activity}):

\begin{figure}[ht]
	\centering
	\includegraphics[width=80mm]{immagini/login}
	\caption{Schemata di avvio}
	\label{login_activity}
\end{figure}

Da questa schermata è possibile effettuare il log in, se l'utente è gia registrato, in caso contrario è possibile registrarsi premendo sul bottone \virgolette{SIGN UP}.
Prima della schermata di registrazione il sistema mostra un messaggio per ricordare all'utente (qualora esso non sia il pazeinte, ad esempio un genitore) di inserire i dati del paziente, poichè non avrebbe senso raccogliere informazioni forvianti (Figura \ref{warning_signup})

\begin{figure}[ht]
	\centering
	\includegraphics[width=55mm]{immagini/warning_registration}
	\caption{Pop up di warning}
	\label{warning_signup}
\end{figure}

Cliccando su \virgolette{CONTINUE} si entra nella vera schermata di registrazione (Figura \ref{popup_signup} ):

\begin{figure}[!ht]
	\centering
	\includegraphics[width=55mm]{immagini/registration}
	\caption{Registrazione nuovi utenti}
	\label{popup_signup}
\end{figure}

Qui bisogna inserire: Nome, Cognome, email, data di nascita, colore preferito e password. Il colore viene utilizzato in caso di password dimenticata, come domanda di sicurezza.
Nell'eventualità in cui un utente si dimentichi la sua password, dalla schermata iniziale (Figura \ref*{login_activity}) premendo su \virgolette{forgot your password?} si accede al pop up di ripristino (Figura \ref{resetpassword}).
 
\begin{figure}[ht]
	\centering
	\includegraphics[width=55mm]{immagini/resetpassword}
	\caption{Pop up di reset della password}
	\label{resetpassword}
\end{figure}

Inserendo l'indirizzo email valido ed il colore corretto, il sistema invia una mail con la nuova password, che sarà possibile ri-personalizzare premendo su \virgolette{update your info} (Figura \ref{login_activity}).
Sempre dalla schermata iniziale è possibile, premendo su \virgolette{?} aprire il sito dedicato a Car Racing Cardboard\footnote{http://3d4amb.unibg.it/3dcar/cardboard\%20site/}(Vedia anche \ref{social_media}).
Cliccando su \virgolette{collaborate with us} è possibile inviare una mail allo staff di 3D4Amb, questo possibilità è stata pensata per collaborazioni con medici e/o centri di ipovisione, interessati a collaborazioni(Figura \ref{cwu}).

\begin{figure}[ht]
	\centering
	\includegraphics[width=55mm]{immagini/collaborate_with_us}
	\caption{Pop up collaborate with us}
	\label{cwu}
\end{figure}
\newpage
Non sarebbe efficiente, ad esempio, per un dottore che ha tre pazienti, dover registrare tre account diversi, in questo caso, è stata prevista la possibilità per i dottori di gestire più pazienti con un unico account, infatti, il sistema è in grado di riconoscere un dottore registrato e lo reindirizza ad una pagina apposita (Figura \ref{doctor_activity}).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=55mm]{immagini/doctor}
	\caption{Schermata per i dottori}
	\label{doctor_activity}
\end{figure}
In questo caso il dottore inserisce i dati del paziente (nome, cognome e data di nascita), il sistema in autonomia verifica se si tratta di un primo inserimento oppure di un \virgolette{log in}. Nel caso di un primo inserimento viene aggiunto un record alla tabella dei pazienti, questo record è collegato a quello del dottore, per consentire poi un eventuale estrazione dei dati di tutti i pazienti di quel dottore.

\paragraph{Giocare senza registrarsi:}
un utente può anche accedere al gioco senza registrarsi sul nostro sistema, cliccando su \virgolette{PLAY WITHOUT REGISTRATION}, in questo caso però non godrà degli stessi servizi di un utente loggato, questa possibilità è stata pensata per chi volesse provare l'applicazione senza per forza dover fornire i propri dati.


\paragraph{Avvio del gioco:}dopo aver effettuato il log in o aver avviato l'applicazione con l'opzione senza registrazione, nel caso di un primo avvio viene visualizzato un \virgolette{video-tutorial} per l'utilizzo del gioco, nel quale vengono descritti i comandi del gioco, è possibile saltare questo video spuntando la checkbox in basso \virgolette{don't show me again}.\\
A questo punto bisogna inserire lo smarthphone nel visore 3D, ed nserire nel sistema a quale occhio si desidera somministrare il trattamento (Figura \ref{fig:chooselazyeye_left}), e premere conferma.\\
Ora inizia il gioco vero e proprio, l'utente può muovere la sua auto a sinistra premendo il tasto \virgolette{+} del controller e a destra premendo il tasto \virgolette{-} (Figura \ref{fig:game}).\\
La difficoltà aumenta dinamicamente, per rendere via via più stimolante il trattamento. Per ogni sessione di gioco un utente ha tre vite, dopo di che, una volta arrivati al \virgolette{game over}, l'applicazione chiede se si desidera ricevere via mail lo storico con i risultati (Figura \ref{schermata_finale}).

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/gameover}
	\caption{Schermata finale}
	\label{schermata_finale}
\end{figure}


%----------------------------------------------------------------------------------------
%	PARTE III
%----------------------------------------------------------------------------------------
\part{Implementazione}
%----------------------------------------------------------------------------------------
%	Panoramica su software e hardware
%----------------------------------------------------------------------------------------
\chapter{Panoramica su software e hardware}
In questo capitolo troviamo l'architettura di sistema con relativo diagramma (\ref{architettura_di_sistema}), una panoramica sul software sotto forma di vista di implementazione (\ref{vista_di_implementazione_software}) infine una serie di scenari e casi d'uso (\ref{scenari_e_casi_d_uso}).

\section{Architettura di sistema}\label{architettura_di_sistema}
Il sistema prevede le seguenti componenti:
\begin{itemize}
	\item Google Cardboard (vedi sezione \ref{sectionGC})
	\item Smartphone Android con connessione internet attiva
	\item Auricolari con tasti di controllo del volume
	\item Server con database MySql
\end{itemize}
Lo smartphone (con S.O. Android) va inserito nel visore, ad esempio Google Cardboard, ma qualora si disponesse di un qualsiasi visore 3D per smartphone il risultato sarà lo stesso,
al dispositivo vanno collegati degli auricolari con il controllo del volume (come quelli che si trovano nelle confezioni dei telefoni all'acquisto), saranno necessari  per controllare il movimento della macchinina.
\begin{figure}[ht]
\centering
\includegraphics[width=160mm]{immagini/architettura_di_sistema}
\caption{Architettura di sistema}
\label{AS}
\end{figure}


\paragraph{La scelta degli auricolari come controller}è nata dopo aver notato come l'utilizzo dell'accelerometro (sensore presente su ogni smartphone) come strumento per catturare i comandi dell'utente, causasse un senso di nausea dopo pochi minuti di gioco, si è quindi deciso di utilizzare un controllore esterno.\\

Dopo di che si è dovuto scegliere il tipo doi controllore, dato che i movimenti da controllare erano solo due (sposta a destra e a sinistra l'auto) per essere coerenti con la scelta di un sistema \textbf{low cost}, la scelta non è ricaduta su un joy-pad, ma piuttosto sugli auricolari dotati del controllo volume, presenti nella confezione degli smartphone o acquistabili a pochi euro.

\paragraph{Il server}è utilizzato per salvare lo storico dei risultati di tutti gli utenti che ne hanno espresso il desiderio, in questo modo è possibile tenere traccia dei loro miglioramenti; è quindi necessario che lo smartphone sia connesso ad internet per poter trasmettere i risultati. Il server è il cs.unibg.it è una macchina Linux e utilizza un database MySql è installato presso il dipartimento di ingegneria dell'Università degli Studi di Bergamo\footnote{http://www.unibg.it/} a Dalmine(Bg). 
\newpage
\section{Vista di implementazione software}\label{vista_di_implementazione_software}
Questo grafico mostra dove sono installate le varie componenti software, in che linguaggio sono scritte e come interagiscono tra di loro (Figura \ref{vista_implementazione_software}).\\
Tutte le componenti lato client (Android), sono realizzate in java e xml, per interagire con il servizio web, passano attraverso una classe che gestisce le chiamate post, rappresentata nel grafico come Post Call Manager. Questa classe lancia una serie di chiamate post, grazie alle quali è possibile gestire: la verifica dei dati per il log in, l'inserimento di un nuovo utente tramite il processo di sign up, la modifica dei dati dell'utente e della propria password e la gestione dei dati di gioco. Tutte queste informazioni vengono memorizzate nel database MySql presente sul server cs.unibg.it. Tramite il servizio web, interamente realizzato in php viene anche gestito l'invio delle email contenenti: il riepiloge dei dati di gioco, notifiche di conferma registrazione, cambiamento dati o modifica della password.
\begin{figure}[ht]
	\centering
	\includegraphics[width=160mm]{immagini/vista_implementazione_software}
	\caption{Vista d'implementazione del software}
	\label{vista_implementazione_software}
\end{figure}

\newpage
\section{Scenari e casi d'uso}\label{scenari_e_casi_d_uso}
%\section{Requisiti funzionali e casi d'uso}
%\subsection{Definizioni dei requisiti:}
%\subsection{Analisi del contesto:}
%\subsection{Scenari e casi d' uso:}
\subsection{Sign Up}
\paragraph{Attori:} Utente
\paragraph{Precondizioni:} E' necessaria una connessione ad internet.
\paragraph{Passi principali:}
\begin{enumerate}
	\item L'utente lancia l'applicazione.
	\item L'utente clicca sul pulsante di Sign Up.
	\item L'utente inserisce i propri dati (first name, last name, email, birthday, favourite color, password, password di conferma) e clicca Ok.
\end{enumerate}
\paragraph{Situazioni eccezionali:}
\begin{enumerate}
	\item[1a.] L'utente lascia vuoti alcuni campi.
	\item[1b.] L'applicazione risponde con un toggle che segnala che alcuni campi sono da compilare e non permette il Sign Up.
\end{enumerate}
\begin{enumerate}
	\item[2a.] L' email inserita dall' utente non esiste.
	\item[2b.] L'applicazione risponde tramite una warning, segnalando all'utente l'insesistenza dell'email inserita, non permettendo la registrazione.
\end{enumerate}
\begin{enumerate}
	\item[3a.] L' email inserita dall' utente è già presente nel database.
	\item[3b.] L'applicazione risponde tramite una warning, segnalando all'utente che la mail non è valida, non permettendo la registrazione.
\end{enumerate}
\begin{enumerate}
	\item[4a.] La data di nascita inserita non è valida.
	\item[4b.] L'applicazione risponde tramite una warning, non permettendo la registrazione.
\end{enumerate}
\begin{enumerate}
	\item[5a.] La password di conferma non corrisponde alla password inserita.
	\item[5b.] L'applicazione risponde tramite una warning, segnalando l'errore e non permettendo il Sign Up.
\end{enumerate}

\paragraph{Postcondizioni:}
I dati inseriti dall'utente sono validi e vengono registrati sul database MySql. L'utente è in grado sfruttare tutti i servizi offerti dall'applicazione accedendo tramite la fase di Log In.

\begin{figure}[ht]
	\centering
	\includegraphics[width=160mm]{immagini/ucSignUp}
	\caption{Use Case Sign Up}
	\label{Use Case Sign Up}
\end{figure}

\newpage
\subsection{Log In utente comune}
\paragraph{Attori:} Utente
\paragraph{Precondizioni:} E' necessaria una connessione ad internet.
\paragraph{Passi principali:}
\begin{enumerate}
	\item L'utente lancia l'applicazione.
	\item L'utente inserisce i campi email e password utilizzati nella fase di Sign Up.
	\item L'utente clicca sul pulsante di Log In.
\end{enumerate}
\paragraph{Situazioni eccezionali:}
\begin{enumerate}
	\item[1a.] L'utente lascia vuoto il campo email o il campo password.
	\item[1b.] L'applicazione risponde con un toggle, il quale segnala che alcuni campi sono da compilare e non permette il Log In.
\end{enumerate}
\begin{enumerate}
	\item[2a.] L'utente inserisce un email non presente nel database.
	\item[2b.] L'applicazione risponde tramite una warning, segnalando all'utente la non presenza dell' email nel database MySql.
\end{enumerate}
\begin{enumerate}
	\item[3a.] L'utente inserisce un email presente nel database ma con password scorretta.
	\item[3b.] L'applicazione risponde tramite una warning, segnalando all'utente che la password inserita non è corretta, non permettendo il Log In.
\end{enumerate}
\paragraph{Postcondizioni:}
Le credenziali di accesso inserite dall'utente sono valide ed il Log In viene eseguito.

\newpage
\begin{figure}[ht]
	\centering
	\includegraphics[width=160mm]{immagini/ucLogInUtente}
	\caption{Use Case Log In utente comune}
	\label{Use Case Log In utente comune}
\end{figure}

\newpage
\subsection{Log In medico}
\paragraph{Attori:} Medico
\paragraph{Precondizioni:} E' necessaria una connessione ad internet. E' necessario che il medico abbia sottomano i dati del paziente.
\paragraph{Passi principali:}
\begin{enumerate}
	\item Il medico lancia l'applicazione.
	\item Il medico inserisce i campi email e password utilizzati nella fase di Sign Up.
	\item Il medico clicca sul pulsante di Log In.
	\item Il medico inserisce i dati del paziente nella form successiva alla fase di Log In.
\end{enumerate}
\paragraph{Situazioni eccezionali:}
\begin{enumerate}
	\item[1a.] Il medico lascia vuoti alcuni dati del paziente
	\item[1b.] L'applicazione risponde con un toggle, il quale segnala che alcuni campi sono da compilare e non permette l'avvio del gioco.
\end{enumerate}
\begin{enumerate}
	\item[2a.] L'utente inserisce una data di nascita non valida per il paziente.
	\item[2b.] L'applicazione risponde tramite una warning, segnalando che la data non è valida e non permettendo l' avvio del gioco.
\end{enumerate}
\paragraph{Postcondizioni:}
Le credenziali del paziente inserite dal medico sono corrette ed il gioco viene avviato.

\newpage
\begin{figure}[ht]
	\centering
	\includegraphics[width=160mm]{immagini/ucLogInMedico}
	\caption{Use Case Log In medico}
	\label{Use Case Log In medico}
\end{figure}
\newpage

\subsection{Update Info}
\paragraph{Attori:} Utente 
\paragraph{Precondizioni:} E' necessaria una connessione ad internet.
\paragraph{Passi principali:}
\begin{enumerate}
	\item L'utente avvia l' applicazione.
	\item L'utente clicca sul link Update Your Info.
	\item L'utente sceglie la credenziale di cui vuole fare l' update.
	\item L'utente effettua il Log In utilizzando le credenziali precenti all'update.
	\item L'utente inserisce il nuovo valore della credenziale da modificare e clicca Ok.
\end{enumerate}
\paragraph{Situazioni eccezionali:}
\begin{enumerate}
	\item[1a.] Le credenziali di Log In non sono valide
	\item[1b.] L'applicazione risponde con un warning e rimanda alla schermata principale.
\end{enumerate}
\begin{enumerate}
	\item[2a.] La nuova credenziale inserita non è valida.
	\item[2b.] L'applicazione risponde tramite una warning, rimandando alla schermata principale.
\end{enumerate}
\paragraph{Postcondizioni:}
L'update delle credenziali selezionate viene eseguito correttamente.
\newpage
\begin{figure}[ht]
	\centering
	\includegraphics[width=160mm]{immagini/ucUpdateInfo}
	\caption{Use Case Update Info}
	\label{Use Case Update Info}
\end{figure}
%----------------------------------------------------------------------------------------
%	Software design
%----------------------------------------------------------------------------------------
\chapter{Software design}

In questo capitolo vengono riportari i classici diagrammi UML, i quali permettono tramite l'utilizzo di modelli visuali, di analizzare, descrivere, specificare e documentare un software, in sequenza di trovano package diagram (\ref{package}), component diagram (\ref{component}) e sequence diagram (\ref{sequence}), i class diagram non sono stati riportati pochè data la mole di codice, sarebbero risultati illeggibili.
\section{Package Diagram}\label{package}
Ecco una panoramica sui package della nostra app, adottiamo una strategia top-down, e partendo da un livello alto, aumentiamo via via il grado di dettaglio.

\begin{figure}[ht]
	\centering
	\includegraphics[width=130mm]{immagini/package_diagram}
	\caption{Package diagram}
	\label{package_diagram}
\end{figure}
\newpage
\section{Component diagram}\label{component}
\subsection{Il sistema di Car Racing Cardboard}\label{post_call}
Le due compoenenti principali del sistema Car Racing Cardboard sono il server cs.unibg.it e l'applicazione Andoid, queste due componenti comunicano con chiamate di tipo http post.\\
A differenza di GET, che permette a un server di mandare informazioni a un client, l'operazione POST fornisce ai client un modo per trasmettere informazioni ai server. 
La maggior parte dei browser web usa comunemente tale metodo per inviare forms ai server Web.
Il client manda un messaggio POST e include l'informazione che desidera mandare al server.
Il server può rimandare l'informazione stessa come parte della risposta \cite{httppost}. \\
\begin{figure}[ht]
	\centering
	\includegraphics[width=100mm]{immagini/component_sistema}
	\caption{Component diagram sistema}
	\label{component sistema}
\end{figure}

\subsection{L'applicazione Android}
Entranto nel dettaglio della prima componete, l'applicazione Android, offre il servizio di interfaccia grafica touch, mentre riceve dal server il servizio di scambio dati http.
I componenti grafici di Android si dividono in due categorie: View e ViewGroup. Una View è un qualunque componente utilizzabile (TextView, EditView, CheckBox, Button, ImageView, ?) in una interfaccia. Una ViewGroup è solitamente un layout che contiene un insieme di View, i più usati sono LinearLayout, RelativeLayout e TableLayout. Un ViewGroup è a sua volta una View, per questo possono essere creati layout complessi annidando a più livelli i vari componenti. View e ViewGroup sono un esempio di pattern composite.
Le interfacce grafiche in Android possono essere definite in due modi (entrambe sfruttate in Car Racing Cardboard):
\begin{itemize}
\item definendo un file xml: ad ogni View corrisponde un tag xml, i ViewGroup sono tag xml che contengono all' interno altri tag;
\item scrivendo codice Java: ogni View ha una classe associata, è possibile aggiungere una View a un ViewGroup usando il metodo addView.
\end{itemize}

\begin{figure}[!ht]
	\centering
	\includegraphics[width=100mm]{immagini/component_android}
	\caption{Component diagram applicazione Android}
	\label{component andoid}
\end{figure}
//BISOGNA SCRIVERE DUE RIGHE SUL SERVER, NON IMMAGINE E BASTA!
%\subsection{Il server}

%\begin{figure}
%\centering
%\includegraphics[width=0.7\linewidth]{immagini/componentServer}
%\caption{Component diagram Server}
%\label{fig:componentServer}
%\end{figure}

%\begin{figure}
%\centering
%\includegraphics[width=0.7\linewidth]{immagini/componentDB}
%\caption{Component diagram Database}
%\label{fig:componentDB}
%\end{figure}


\subsection{Dettaglio applicazione} 
L'applicazione per quanto riguarda la componente algoritmica (intesa come la parte che non  riguarda la GUI), è composta dalle Activity, ossia le varie schermate di un'applicazione Android, le quali si occupano di \virgolette{tradurre} gli input dell'utente in output implementati tramite codice java.\\
Sulle Activity si appoggiano i thread, utilizzati per gestire l'esecuzione del gioco nella sua ripetizione ciclica, infine gli asynctask, utilizzati per alleggerire l'esecuzione dei thread sulla User Interface (Figura \ref{component_applicazione}).

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{immagini/component_applicazione}
\caption{Component applicazione}
\label{component_applicazione}
\end{figure}

\newpage
\section{Sequence diagram}\label{sequence}
\subsection{Funziononamento con log in}
All'avvio dell'applicazione, se l'utente ho inserito correttamente email e password, nell' interfaccia corrente viene visualizzata una \virgolette{rotella} di attesa (dialog ring), mentre in background vengono scatenate una serie di chiamate:
\begin{itemize}
	\item alla classe PostCall vengono passate la stringa contentente l'email e quella della password
	\item la classe PostCall effettua una chiamata post al server cs.unibg.it, più precisamente al servizio 3d4ambservice.php
\end{itemize}
Il servizio php verifica nel database se l'email e la password sono corrette, e manda un messaggio di risposta alla PostCall, la quale effettua un parsing della risposta e restituisce un messaggio all'interfaccia corrente.\\
A questo punto la dialog ring viene interrotta, e nel caso di un email e password corrette, viene lanciata l'activity TutorialActivity, nella quale è presente una breve spiegazione del gioco, gestita tramite un thread.\\
Terminata la presentazione della TutorialActivity (che può anche essere saltata spuntando un'apposita checkbox) viene lanciata la SplashActivity, la quale contine un animazione d'avvio. Viene avviata ora la SettingsActivity, nella quale viene chiesto qual è l'occhio pigro che si vuole trattare.\\
Confermata la scelta dell'occhio, si apre la MainActivity, contenente il gioco vero e proprio, i thread principali sono tre:
\begin{enumerate}
	\item GameThread: che gestisce i nemici e l'auto dell'utente
	\item TimerPanorama: per la gestione del panorama laterale
	\item TimerSun: per la gestione del sole e delle nuvole sulle sfondo
\end{enumerate}
Terminato il gioco (gameover) è possibile richiedere i risultati via mail oppure ricominciare a giocare, in ogni caso viene fatta una chiamata post per memorizzare i risultati sul server.(Figura \ref{sequence_login})
\begin{figure}[ht]
	\centering
	\includegraphics[angle=90,width=\columnwidth]{immagini/sequence_login}
	\caption{sequence diagram funzionamento app con login}
	\label{sequence_login}
\end{figure}



\subsection{Funziononamento senza log in}
Il funzionamento in modalità \virgolette{play without registration} è identico a quello del log in utente, infatti, in questo caso è stato definito un utente di default, al quale vengono associati tutti i risultati degli utenti che hanno giocato senza registrarsi.

\subsection{Funziononamento sign up}
Per quanto riguarda la reigstrazione di nuovi utenti, una volta premuto il bottone \virgolette{SIGN UP}, si apre un pop up di warning, dopo di che ,se è stato premuto il tasto di confemra, come verrà poi approfondito nella sezione \ref{signup_label}, l'utente deve fornire: nome, cognome, email, colore preferito, data di nascita e password.\\
Viene passato il tutto alla classe PostCall, che a sua volta effettua una chiamata post al servizio 3d4ambservice.php. Se i dati inseriti sono corretti (l'email è esistente e non ci sono gi record nel db con gli stessi attributi), il nuovo utente viene inserito.(Figura \ref{sequence_signup})
\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/sequence_signup}
	\caption{sequence diagram funzionamento app registrazione utente (sign up)}
	\label{sequence_signup}
\end{figure}



%----------------------------------------------------------------------------------------
%	analisi degli algoritmi
%----------------------------------------------------------------------------------------

\chapter{Analisi degli Algoritmi}
In questo capitolo vengono spiegati gli algoritmi che compongono questa applicazione: la penalizzazione progressiva delle immagini (\ref{penalizzazione_progressiva}), come la scena viene generata casualmente (\ref{generazione_random_scena}), come vengono cifrate le password degli utenti (\ref{cifratura}), una panoramica sul servizio web (\ref{servizio_web}), come vengono gestiti gli scontri con i nemici (\ref{gestione_dello_scontro_con_nemico}), il thread principale del gioco (\ref{game_thread}), la gestione delle animazioni (\ref{gestione_animazione}) ed i task asincroni utilizzati (\ref{asynctask}).

\section{Penalizzazione progressiva delle immagini}\label{penalizzazione_progressiva}
L'alpha value di un immagine è un valore che va da 0 a 255 e descrive la sua trasparenza. Un' immagine con alpha=0 è trasparente, mentre con aplha=255 conserva tutte le sue caratteristiche, con questo codice all' aumentare del livello, aumenta anche la trasparenza dell'immagine, dopo l'ottavo livello l'alpha rimane=50, continua però ad aumentare la difficoltà del gioco, in termini di nemici e velocità d'azione. \\
\begin{lstlisting}[language=Java]
	 /**
	 *
	 * @return Alpha value to penalize the image
	 */
	 private int getLevelPenalization(){
		 switch(globalData.getLevel()){
	 
			 case 1:{
				 return 200;
			 }
			 case 2:{
				 return 180;
			 }
			 case 3:{
				 return 160;
			 }
			 case 4:{
				 return 140;
			 }
			 case 5:{
				 return 120;
			 }
			 case 6:{
				 return 100;
			 }
			 case 7:{
				 return 80;
			 }
			 case 8:{
				 return 50;
			 }
			 default:{
				 return 50;
			 }
		 }
	 }
\end{lstlisting}
\newpage
\section{Generazione random scena}\label{generazione_random_scena}
\subsection{Nemici}
Nella scena ci sono tre \virgolette{corsie} dalle quali possono arrivare i \virgolette{nemici}, questo è il codice dal quale viene estratat la corsia scelta.
Inizialmente la corsia viene scelta a caso con un'estrazione random, ma per evitare che il giocatore resti troppo a lungo fermo nella stessa corsia senza muoversi viene fatto un controllo sulla scelta precedente. Un nemico non viene mai mandato più di due volte sulla stessa corsia.
\begin{lstlisting}[language=Java]
	public void randomFunction(){
		selectedLane=(int)(lane*Math.random())+1;
		if(previousLane==selectedLane){
			countPrevious++;
			if(countPrevious>3){
			   	selectedLane++;
				if(selectedLane>3) selectedLane=1;
			}
		}
		previousLane=selectedLane;
		selectedCar=(int)(numberOfCar*Math.random())+1;	
	}
\end{lstlisting}

\subsection{Panorama}
Analogamente ai nemici, anche il panorama viene modificato per rendere più avvincente l'ambientazione del gioco.

\begin{lstlisting}[language=java]
public void randomPanorama() {
	int pick = new Random().nextInt(Side.values().length);
	selectedSide= Side.values()[pick];
	idSubject= (int)(numberOfSubject*Math.random())+1;
}
\end{lstlisting}

\newpage
\section{Cifratura password}\label{cifratura}

Le password degli utenti non vengono memorizzate nel Data Base in chiaro ma vengono cifrate (dallo smartphone) con un algoritmo sha256.\\
Solitamente tale algoritmo viene utilizzato per generare un' \virgolette{impronta digitale} di un documento, in questa applicazione è stato usato in questo modo poichè in java viene fornita una funzione di default, molto leggera, che appunto cifra in sha256.\\
Nei confronti degli utenti di Car Racing Cardboard non era corretto memorizzare le password in chiaro, a seguire il codice implementato.\\ 
\begin{lstlisting}[language=Java]
	public static String calculateHash(String data) {
		String hash = new String(Hex.encodeHex(DigestUtils.sha256(data)));
		return hash;
	}
\end{lstlisting}
\newpage
\section{Servizio web}\label{servizio_web}
La comunicazione tra \textbf{client} (smarthphone) e \textbf{server} (cs.unibg.it) avviene tramite chiamate post (vedi anche \ref{post_call}), le chiamate sono sincrone, ossia ad un messaggio inviato dal client corrispondono sempre delle risposte dal servizio. Le chiamate partono sempre dal client, il server di suo non invia messaggi.
\paragraph{Il thread della chiamata post}la chiamata avviene nel metodo \textit{public void myPostCall(final TypeCall type, final Activity logInActivity)} grazie ad un thread al suo interno.
\\
\begin{lstlisting}[language=java]
// Create a new HttpClient and Post Header
thread = new Thread(new Runnable() {
	@Override
	public void run() {
		HttpClient httpclient = new DefaultHttpClient();
		HttpPost httppost = new HttpPost("http://3d4amb.unibg.it/3dcar/3d4ambService.php");
		[...]
	}
}			
\end{lstlisting}

La chiamata viene fatta al servizio php di Car Racing Cardboard (3d4ambService.php).
\newpage
Le chiamate possibili sono varie, per ognuna è stato predisposto una lista di stringhe che possono essere passate all'oggetto httppost:
\\
\begin{lstlisting}[language=java]
List<NameValuePair> nameValuePairsUpdateString = new ArrayList<NameValuePair>(3);
List<NameValuePair> nameValuePairsLogIn = new ArrayList<NameValuePair>(3);
List<NameValuePair> nameValuePairsReset = new ArrayList<NameValuePair>(5);
List<NameValuePair> nameValuePairsSignUp = new ArrayList<NameValuePair>(7);
List<NameValuePair> nameValuePairsDoctorCall = new ArrayList<NameValuePair>(5);
List<NameValuePair> nameValuePairsReport = new ArrayList<NameValuePair>(4);

\end{lstlisting}

\paragraph{La gestione delle chiamate lato server} le chiamate fatte a lato client, gestite tramite l'arrayList "ArrayList<NameValuePair>(i)", vengono ricevute a lato server eseguendo una POST sul parametro "type", in seguito alla connessione a MySql ed alla selezione del database:
\\
\begin{lstlisting}[language=php]

$server = "localhost";
$user = "3d4amb";
$pass = "amb43d";
$db = "cardboard";

//Connect to mysql 
$conn=mysql_connect($server,$user,$pass) or die("errore mysql");

//Select the db
mysql_select_db($db) or die("sorry,can't connect to the database.");

$type = $_POST['type'];

\end{lstlisting}

In seguito all'inizializzazione del parametro "type", che specifica se è stata richiesta una procedura di Sign Up, Log In, Report e così via, viene eseguito uno 'switch' per intraprendere diverse azioni in base alla procedura scelta.
\newpage
\subsection*{Log in}La chiamata post per il login avviene ogni volta che l'utente preme il bottone di login (Figura \ref{login_post}):
\begin{figure}[ht]
	\centering
	\includegraphics[width=50mm]{immagini/login_post}
	\caption{}
	\label{login_post}
\end{figure}

Per il login vengono inviate al server email e password, che prima di essere inviata viene cifrata (vedi \ref{cifratura}).\\
A questo punto viene lanciata la finestra di attesa (Figura \ref{attesa}):
\begin{figure}[ht]
	\centering
	\includegraphics[width=70mm]{immagini/attesa}
	\caption{interfaccia di attesa}
	\label{attesa}
\end{figure}

Se il servizio risponde in maniera positiva viene lanciata l'activity successiva (SplashActivity o TutorialActivity a seconda delle impostazioni utente).
\\

La procedura di Log In è trattata nel seguente modo a lato server:
\\
\begin{lstlisting}[language=php]

case "log_in":
	$emailFound = false;
	$email = $_POST['email']; 
	$password = $_POST['password'];
	$sqlSelectAllFromUsers = "SELECT * FROM users";
	$querySelectAllFromUsers = mysql_query($sqlSelectAllFromUsers);
	
	while($row = mysql_fetch_array($querySelectAllFromUsers)) {
		if($email == $row['email'] && $email!= NULL) {
			$emailFound = true;
			if($password == $row['password']) {
				$statusConnection = true;
				$id_user = $row['id'];
				$doc = $row['doctor'];
			}
			else {
				echo "password errata";
			}
		}
	}
	
	if($emailFound == false) {
		echo "emailNotFound";
	}
	if($statusConnection == true) {
		echo "connection/".$id_user."/".$doc;
	}
	
	break;
\end{lstlisting}

Come si può vedere sopra, viene eseguito un controllo sui campi email e password e viene restituita una stringa che informa sull'esito. Viene inoltre restituito un valore concatenato (\$doc, 0 or 1) per indicare se si tratta del Log In di un utente comune o di un dottore, il quale dovrà quindi aggiungere successivamente i dati del paziente.
\newpage
\subsection*{Sign up}\label{signup_label}
L'evento post call per la registrazione (sign up) avviene dopo che l'utente ha premuto il tasto \virgolette{ok} (Figura \ref{registration_post})
\begin{figure}[ht]
	\centering
	\includegraphics[width=70mm]{immagini/registration_post}
	\caption{}
	\label{registration_post}
\end{figure}

La chiamata al server passa i seguenti parametri:

\begin{itemize}
	\item nome
	\item cognome
	\item email
	\item colore preferito
    \item data di nascita
	\item password
\end{itemize}

Se va tutto a buon fine il nuovo utente viene inserito nel database:\\

\begin{lstlisting}[language=php]

case "sign_up":

	$firstname = $_POST['first_name'];
	$lastname = $_POST['last_name'];
	$email = $_POST['email'];
	$password = $_POST['password'];
	$color = $_POST['color'];
	$date = $_POST['date'];
	$doctor = false;
	$emailAlreadyChecked = false;
	$patient = false;
	
	// include SMTP Email Validation Class
	require_once('smtp_validateEmail.php');

	// instantiate the class
	$SMTP_Validator = new SMTP_validateEmail();
	
	// turn on debugging if you want to view the SMTP transaction
	//$SMTP_Validator->debug = true;
	
	// do the validation
	$results = $SMTP_Validator->validate(array($email), 
		"3D4AmbUnibg@gmail");
	
	if ($results[$email]) {
		$sqlSelectAllFromUsers = "SELECT * FROM users";
		$querySelectAllFromUsers = mysql_query($sqlSelectAllFromUsers);
		while($row = mysql_fetch_array($querySelectAllFromUsers)) {
			if($email == $row['email']) {
				$emailAlreadyChecked = true;
			}
		}

		if($emailAlreadyChecked == false) {	
			//insert user into DB
			$sqlInsertNewUser = "INSERT INTO users (firstname,
			lastname,birthday,email,patient,color,password) values ('$firstname','$lastname','$date','$email','$patient','$color','$password')";
			$queryInsertNewUser = mysql_query($sqlInsertNewUser);

			//send mail registration
			gmail($email,"REGISTRATION 3D4AMB","Hello dear ".$email.", welcome to 3d4Amb!".'<br> <br>'."
			The 3D4Amb project aims at developing a system based on the 3D for the diagnosis and treatment of amblyopia in young children.
			Below you can find your authentication data:".'<br> <br>'."Firstname: ".$firstname.'<br>'."
			Lastname: ".$lastname.'<br>'."
			Email: ".$email.'<br>'."
			Birthday: ".$date.'<br>'."
			Favourite color: ".$color.'<br> <br>'.
			"If you want change your info, you can go over 'update you info'.
			Thanks for using our application, best regards.".'<br> <br>'." 3d4amb Staff".'<br> <br>'."Contact us on: 3D4AmbUnibg@gmail.com"
			.'<br> <br>'."Visit our site on: http://3d4amb.unibg.it");
			
			echo "emailChecked";
		}
		else {
			echo "emailAlreadyExist";
		}
	}
	else {
		echo "emailNotChecked";
	}

break;

\end{lstlisting}

Nella gestione della registrazione utente lato server vengono innanzitutto inizializzate le variabili contenenti i dati dell'utente catturati dalle textBox dell'applicazione. In seguito viene controllato che l'email inserita non sia già presente nel database. I controlli relativi all'inserimento di campi nulli o non validi vengono effettuati direttamente dall'applicazione a lato client. Se i valori inseriti dall'utente sono corretti e l'email non è già presente nel database si procede alla registrazione dell'utente nel database ed all'invio di un' email di benvenuto. Durante questa fase si è utilizzata la funzione 'gmail(\$to, \$subject, \$message)' appartenente alla classe 'SMTP\_validateEmail', in cui viene eseguito un controllo approfondito sull'esistenza e sulla validità dell' email inserita dall'utente. In caso di esito positivo o negativo, viene sempre restituita una stringa a lato client che specifica l'esito dell' operazione. Se la procedura viene eseguita con successo, l'utente riceve una mail di conferma analoga alla seguente: (Figura \ref{conferma_registrazione})

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/email_registrazione}
	\caption{email di conferma registrazione}
	\label{conferma_registrazione}
\end{figure}
\newpage
\subsection*{Reset}
Il reset della password avviene quando l'utente preme sul tasto \virgolette{forgot your password?}, viene richiesta l'email e il colore preferito, se i dati superano la verifica sul database, viene generata random una nuova password alfanumerica di otto caratteri, che potrà poi successivamente essere personalizzata (vedi \ref{guida}), e verrà inviata la seguente email (Figura \ref{reset_password})

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/email_reset_password}
	\caption{email di reset della password}
	\label{reset_password}
\end{figure}

L' operazione di reset della password è gestita a livello server nel seguente modo:
\\
\begin{lstlisting}[language=php]
	
	case "reset":
	
	$new_password = $_POST['new_password'];
	$new_passwordCfr = $_POST['new_passwordCfr'];
	$email = $_POST['email'];
	$color = $_POST['color'];
	$sqlSelectColor = "SELECT * FROM users WHERE email = '$email'";
	$querySelectColor = mysql_query($sqlSelectColor);
	
	while($row = mysql_fetch_array($querySelectColor)) {
		if($row['color'] == $color ) {
			$id_user=$row['id'];
			$sqlInsertNewPassword = "UPDATE users SET password='$new_passwordCfr' WHERE id='$id_user'";
			$queryInsertNewPassword = mysql_query($sqlInsertNewPassword);
	
			//send email password changed
			gmail($email,"PASSWORD CHANGED SUCCESSFULLY","Hello dear ".$email."!".'<br> <br>'."Your password
			has been changed and the new password is: ".$new_password.". 
			If you want customize your password, you can go over 'update you info'. 
			Thanks for using our application, best regards.".'<br> <br>'." 3d4amb Staff".'<br> <br>'."Contact us on: 3D4AmbUnibg@gmail.com"
			.'<br> <br>'."Visit our site on: http://3d4amb.unibg.it");
			echo "colorTrue";
		}
		else {
			echo "colorFalse";
		}
	}
	
	break;

\end{lstlisting}

Come si può vedere, vengono dapprima catturati i valori relativi alla nuova password (cifrata e non), il valore dell'email ed il valore relativo al colore preferito, necessario per la verifica dell' identità dell'utente. Sulla base dell' email indicata viene poi eseguito un controllo tra il valore di colore inserito e quello indicato in fase di Sign Up. Se i due valori sono congruenti allora l'operazione di ripristino della password viene eseguita con successo. L' utente riceverà quindi un email contenente la nuova password.
\newpage
\subsection*{Doctor call}
Nel caso in cui un utente, memorizzato come dottore nel nostro database, effettua il log in, viene reindirizzato ad un' apposita paginia; si tratta della DoctorActivity, nella quale il dottore può inserire i dati del paziente, consentendogli così di gestirli tutti con il suo account su Car Racing Cardboard (vedi anche \ref{guida}).\\
L' utilizzo dell'applicazione da parte di un dottore prevede come detto il Log In tramite le credenziali del medico, l' inserimento dei dati del paziente e l' avvio del vero proprio gioco con l'identificativo univoco del paziente (id\_user), per il monitoraggio delle prestazioni ed il salvataggio dei dati in modo ordinato nel database.
La gestione lato server dell' avvio di una partita da parte di un dottore, dopo avere inserito i dati del paziente, è stata realizzata nel seguente modo: 
\\
\begin{lstlisting}[language=php]

case "doctorcall":

	$first_name = $_POST['first_name'];
	$last_name = $_POST['last_name'];
	$id_doctor = $_POST['id_doctor'];
	$birthday = $_POST['birthday'];
	$patient = true;
	$patientAlreadyExist = false;
	
	$sqlSelectAllFromUsers1 = "SELECT * FROM users";
	$querySelectAllFromUsers1 = mysql_query($sqlSelectAllFromUsers1);
	
	while($row = mysql_fetch_array($querySelectAllFromUsers1)) {
		if($first_name == $row['firstname'] &&
		 $last_name == $row['lastname'] &&
		 $birthday == $row['birthday'] &&
		 $patient == true) {
			 $patientAlreadyExist = true;
			 $id_user = $row['id'];
		}
	}
	
	if($patientAlreadyExist == false) {
		$sqlInsertDoctorPatient = "INSERT INTO users (firstname,lastname,birthday,patient,id_doctor) values ('$first_name','$last_name','$birthday',
		'$patient','$id_doctor')";
		
		$queryInsertDoctorPatient = mysql_query($sqlInsertDoctorPatient);
		
		$sqlSelectAllFromUsers = "SELECT * FROM users";
		
		$querySelectAllFromUsers = mysql_query($sqlSelectAllFromUsers);
		
		while($row = mysql_fetch_array($querySelectAllFromUsers)) {
			if($first_name == $row['firstname'] &&
			 $last_name == $row['lastname'] &&
			 $birthday == $row['birthday'] &&
			 $row['patient'] == true) {
				 $id_user = $row['id'];
			}
		}
	}
	
	echo $id_user;
	
	break;

\end{lstlisting}

Prima di avviare una partita viene controllato se il paziente è già presente nel database, in tal caso verrà restituito come valore 'id\_user' il valore pescato dal database. In caso si tratti di un nuovo paziente, si procede all'inserimento dei nuovi dati nel database e viene creato un nuovo 'id\_user'.
\newpage
\subsection*{Report}

La fase di report nell' applicazione è differenziata per due diverse casistiche, ovvero l' utilizzo del gioco da parte di un utente registrato e l' utilizzo del gioco senza registrazione. Nel caso si usufruisca dell' applicativo come utente non registrato, alla fine della partita viene semplicemente visualizzata una finestra contenente i dati relativi ai punteggi raggiunti. Nel caso invece si sfrutti la possibilità di registrarsi, si ottiene il privilegio di salvataggio e monitoraggio automatico dei risultati raggiunti (Figura \ref{Gameover}).

\begin{figure}[h]
	\centering
	\includegraphics[width=\columnwidth]{immagini/gameover.png}
	\caption{Schermata finale del gioco}
	\label{Gameover}
\end{figure}

A livello di codice, nel thread del gioco (vedi anche sezione \ref{game_thread}), viene lanciata una chiamata post, passando come parametri il punteggio ottenuto, il livello raggiunto e i dati dell' utente:
\begin{lstlisting}[language=java]
	 PostCall postCall= new PostCall(globalData.getScore().toString(),globalData.getLevel().toString(),id_user,t2,true);
	 postCall.myPostCall(TypeCall.REPORT,activity);
\end{lstlisting}

Vediamo ora nel dettaglio la gestione della fase di report lato server per quanto riguarda gli utenti registrati, siano essi pazienti di dottori o meno:
\\
\begin{lstlisting}[language=php]

case "report_and_email":
	$score = $_POST['score'];
	$level = $_POST['level'];
	$id_user = $_POST['id_user'];
	$isDoctor = false;
	
	$sqlInsertReport = "INSERT INTO results(id_user,score,level,date)
		values ('$id_user','$score','$level',now())";
	$queryInsertReport = mysql_query($sqlInsertReport);

	$sqlSelectAllFromUsers2 = "SELECT * FROM users WHERE id='$id_user'";
	$querySelectAllFromUsers2 = mysql_query($sqlSelectAllFromUsers2);
	$sqlSelectAllFromResults = "SELECT * FROM results WHERE id_user='$id_user'";
	$querySelectAllFromResults = mysql_query($sqlSelectAllFromResults);
	
	while($row = mysql_fetch_array($querySelectAllFromUsers2)) {
		$patient_firstname = $row['firstname'];
		$patient_lastname = $row['lastname'];
		
		if($row['patient'] == NULL) {
			$message="Hello ".$row['email']."!".'<br> <br>'."These are your results: ".'<br> <br>';
			while($row3 = mysql_fetch_array($querySelectAllFromResults)) {
				$extract=$extract.
				"SCORE: ".$row3['score'].".".'<br>'.
				"LEVEL: ".$row3['level'].".".'<br>'.
				"DATE: ".$row3['date'].".".'<br> <br>';
			}
			$message=$message.$extract.
			"Carry on playing in order to improve your lazy eye! Thank you for using our app. Regards.".'<br> <br>'." 3d4amb Staff".'<br> <br>'."Contact us on: 3D4AmbUnibg@gmail.com".'<br> <br>'."Visit our site on: http://3d4amb.unibg.it";
			
			gmail($row['email'],"3D4AMB SCORE",$message);
		}
		else {
			$id_doctor = $row['id_doctor'];
			$sqlSelectDoctorFromUsers = "SELECT * FROM users WHERE id='$id_doctor'";
			$querySelectDoctorFromUsers = mysql_query($sqlSelectDoctorFromUsers);
			while($row1 = mysql_fetch_array($querySelectDoctorFromUsers)) {
				gmail($row1['email'],"3D4AMB SCORE","Hello dear ".$row1['email']."!".'<br> <br>'."There are the results of your patient's game : "
				.'<br> <br>'."PATIENT'S FIRSTNAME: ".$patient_firstname."."
				.'<br> '."PATIENT'S LASTNAME: ".$patient_lastname."."
				.'<br> '."SCORE: ".$score.".
				".'<br>'."LEVEL: ".$level.".".'<br> <br>'."
				Continues to play to improve your results! 
				Thanks for using our application, best regards.".'<br> <br>'." 3d4amb Staff".'<br> <br>'."Contact us on: 3D4AmbUnibg@gmail.com"
				.'<br> <br>'."Visit our site on: http://3d4amb.unibg.it");
			}
		}
	}

echo "report_and_email";

break;

\end{lstlisting}

Come si può vedere, una volta finita la partita, i risultati ottenuti dall' utente vengono inseriti nella tabella 'results'. In seguito viene individuato lo storico dell' utente dal database e viene inviata una mail che notifica i risultati ottenuti fino all' ultima partita effettuata. L' obiettivo è quello di mantenere una cronologia che permetta all' utente di osservare progressivamente i miglioramenti ottenuti.

\newpage
\section{Gestione dello scontro con il nemico}\label{gestione_dello_scontro_con_nemico}

Nel momento in cui si effettua una collisione con un autoveicolo nemico, oltre al decremento del numero di vite a disposizione ed alla gestione di un eventuale Game Over, viene visualizzata a schermo un' esplosione animata nel punto di scontro. Questo effetto è stato progettato basandosi sulle potenzialità dei Thread e sfruttando le potenzialità della classe SurfaceView, messa a disposizione da Android.
Essa fornisce infatti una superficie di disegno pienamente controllabile che può essere adoperata per effettuare delle sovrapposizioni grafiche con altre View. L' accesso alla superficie sottostante è fornito tramite l' interfaccia SurfaceHolder, la quale può essere richiamata usando il metodo getHolder(). Nella classe, è necessario implementare i  metodi 'surfaceCreated(SurfaceHolder)' e 'surfaceDestroyed(surfaceHolder)' che agiscono quando la superficie viene creata e distrutta. Lo scopo principae della classe SurfaceView è quello di fornire una superficie dove un thread secondario possa renderizzare a schermo. Per questo obiettivo, vengono utilizzate delle Callback sull' oggetto SurfaceHolder per fare da filo conduttore tra thread principale e secondario. Di seguito è riportata la classe AnimationExplosionView, la nostra estensione della classe SurfaceView precedentemente descritta:

\begin{lstlisting}[language=java]

public class AnimationExplosionView extends SurfaceView {
	private SurfaceHolder holder;
	private AnimationLoopThread gameLoopThread;
	private Sprite spriteExplosion;
	
	public AnimationExplosionView(Context context)
	{
		super(context);
		gameLoopThread = new AnimationLoopThread(this);
		setZOrderOnTop(true);
		holder = getHolder();
		holder.addCallback(new SurfaceHolder.Callback() {
			@Override
			public void surfaceDestroyed(SurfaceHolder holder) {
				boolean retry = true;
				gameLoopThread.setRunning(false);
				while (retry) {
					try {
						gameLoopThread.join();
						retry = false;
					} 
					catch (InterruptedException e) {
					}
				}
			}
	
			@Override
			public void surfaceCreated(SurfaceHolder holder) {
				gameLoopThread.setRunning(true);
				gameLoopThread.start();
			}
			
			@Override
			public void surfaceChanged(SurfaceHolder holder, int format,
				int width, int height) {
			}
		});
		
		holder.setFormat(PixelFormat.TRANSPARENT);
		createSprite();
	}
			
			
	private void createSprite()
	{
		Bitmap bmpExplosion = BitmapFactory.decodeResource(getResources(),
		 R.drawable.explosion_anim);
		spriteExplosion = new Sprite(this,bmpExplosion,12);
	}


	public void onDrawAnimationExplosionView(Canvas canvas)
	{
		if(canvas!=null)
			spriteExplosion.onDrawExplosion(canvas);
	}
}


\end{lstlisting}

Come si può osservare dal codice, nella classe vengono utilizzati anche oggetti di tipo Bitmap. Questi oggetti sono molto utili per la rappresentazione di immagini in formato raster. Inoltre si istanzia anche un oggetto GameLoopThread, il quale ha il compito di richiamare ad intervalli regolari il metodo onDrawAnimationExplosionView(Canvas canvas). Il principio dell' animazione dell' esplosione è infatti dato dallo scorrimento di un vettore diviso in colonne aventi la medesima dimensione. Ogni colonna contiene 'l' evoluzione' dell' animazione e lo scorrimento veloce da parte del thread simula l'effetto dell'esplosione:
\\

\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{immagini/explosion_anim1.png}
\caption{Vettore esplosione}
\label{vettore esplosione}
\end{figure}

\newpage

In AnimationExplosionView viene inoltre istanziato l'oggetto spriteExplosion della classe Sprite. Il costruttore della classe Sprite accetta come parametri la SurfaceView , la Bitmap ed il numero di colonne in cui è divisa la bitmap da scorrere. Il metodo richiamato da GameLoopThread 'onDrawAnimationExplosionView(Canvas canvas)' chiama a sua volta il metodo 'onDrawExplosion(Canvas canvas)' sull'oggetto spriteExplosion. Tale metodo va effettivamente a disegnare a schermo la nostra animazione:

\begin{lstlisting}[language=java]

public void onDrawExplosion(Canvas canvas)
{
	updateExplosion();
	if(canvas!=null)
		canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR);
	
	int srcX = currentFrame * bmpWidth;
	int srcY = 0;
	Rect src = new Rect(srcX, 0, srcX + bmpWidth, srcY + bmpHeight);
	Rect dst = new Rect(xExplosion, yExplosion, xExplosion + bmpWidth, yExplosion + bmpHeight);
	if(canvas!=null)
		canvas.drawBitmap(bmp, src, dst, null);
}

\end{lstlisting}

La bitmap viene disegnata all'interno di un rettangolo avente le dimensioni dei singoli frame, nel punto specificato dai valori 'xExplosion' e 'yExplosion'. Il metodo updateExplosion() non fa altro che scorrere la nostra immagine sulla base del frame corrente e del numero di colonne specificato in fase di costruzione:

\begin{lstlisting}[language=java]

    private void updateExplosion()
    {
	    currentFrame = ++currentFrame % nColums;
    }

\end{lstlisting}


\newpage
\section{Game Thread}\label{game_thread}

L' implementazione del cuore di funzionamento del gioco è stata realizzata nella classe GameThread. Essa estende la classe Thread e ne effettua l' override di alcune funzioni, come ad esempio la funzione 'run()', che vedremo in seguito in dettaglio. Innanzitutto, nel costruttore della classe GameThread vengono accettati ed in seguito istanziati tutti gli oggetti relativi alla composizione grafica del gioco, come ad esempio le imageView relative agli autoveicoli, quelle relative al paesaggio, le textBox principali ed i relativeLayout riguardanti l' occhio destro e sinistro, con le relative dimensioni di larghezza ed altezza. Altro importante parametro accettato è l' enumerativo che identifica l'occhio scelto. Ci sono poi l'activity da cui parte la chiamata, l'id dell'utente ed il parametro della classe GlobalData, per tenere traccia dei parametri del gioco. Di seguito viene riportata la segnatura del costruttore precedentemente descritto:

\begin{lstlisting}[language=java]

public GameThread(Activity activity, TextView text1, TextView text2, 
TextView tLevelLeft, TextView tLifeLeft, TextView tScoreLeft,
TextView tLevelRight, TextView tLifeRight, TextView tScoreRight, ArrayList<ImageView> i1,ArrayList<ImageView> i2,ArrayList<ImageView> 	i3,ArrayList<ImageView> i4,ArrayList<ImageView> i5,ArrayList<ImageView> i6,ImageView target1, ImageView target2, ImageView target3,
GlobalData globalData, Eye eye, RelativeLayout RLAnimationLeft, RelativeLayout RLAnimationRight,
int width, int height,String id_user) { ... }

\end{lstlisting}

Il fulcro della classe GameThread è contenuto all' interno del metodo run(). In esso inoltre, le principali azioni vengono lanciate all' interno del metodo runOnUiThread(), il quale esegue le procedure specificate sul thread dell' interfaccia utente. In primo luogo, nel thread, viene controllato il numero di vite attuale dell' utente. Se il valore delle vite rimaste è pari a '0', vengono eseguite le procedure relative alla fase di GameOver, come ad esempio la visualizzazione della view di report a schermo e l'invio della mail contenente lo storico ed i progressi dell'utente, in caso di gioco con utente registrato. Nel caso invece il valore del numero di vite sia maggiore di 0, vengono mantenuti aggiornati i valori di score, level e numero di vite, e viene settata la corsia sul quale viene immesso il nemico, scelta dall'algoritmo random precedentemente esplicato. Si esegue poi un controllo sulla corsia scelta per predisporre le animazioni a destra, a sinistra o centralmente. Se ad esempio il nemico viene posto sulla corsia centrale (pick = 2), le azioni intraprese sono le seguenti:

\begin{lstlisting}[language=java]

if (pick == 2) {
	if(gameManager.getIdEnemy().get(i).getNumberOfCar()==1) {
		animationEnemies.showImage(enemyLeftLane2.get(0));
		animationEnemies.showImage(enemyRightLane2.get(0));
		animationEnemies.animateFrontCarLane2(enemyLeftLane2.get(0), enemyRightLane2.get(0),
			displayWidth, displayHeight);
	}
	if(gameManager.getIdEnemy().get(i).getNumberOfCar()==2) {
		animationEnemies.showImage(enemyLeftLane2.get(1));
		animationEnemies.showImage(enemyRightLane2.get(1));
		animationEnemies.animateFrontCarLane2(enemyLeftLane2.get(1), enemyRightLane2.get(1),
			displayWidth, displayHeight);
	}
	if(gameManager.getIdEnemy().get(i).getNumberOfCar()==3) {
		animationEnemies.showImage(enemyLeftLane2.get(2));
		animationEnemies.showImage(enemyRightLane2.get(2));
		animationEnemies.animateFrontCarLane2(enemyLeftLane2.get(2), enemyRightLane2.get(2),
			displayWidth, displayHeight);
	}
	if(gameManager.getIdEnemy().get(i).getNumberOfCar()==4) {
		animationEnemies.showImage(enemyLeftLane2.get(3));
		animationEnemies.showImage(enemyRightLane2.get(3));
		animationEnemies.animateFrontCarLane2(enemyLeftLane2.get(3), enemyRightLane2.get(3),
			displayWidth, displayHeight);
	}
	
	onAnimationTimer();
	animationTarget.animateTarget2(target2, displayWidth, displayHeight);
	animationEnemies = new AnimationEnemies();
}

\end{lstlisting}

Per trattare l' implementazione vera e propria dell'animazione sull' oggetto animationEnemies rimandiamo al capitolo seguente per esplicarla più in dettaglio. Il metodo onAnimationTimer() implementa a sua volta i listener contenenti i metodi onAnimationRepeat, onAnimationStart ed onAnimationEnd, necessari per la gestione dei vari eventi rispettivamente a inizio e fine animazione. Dato che non è possibile agire nel momento in cui le animazioni sono in corso, ma soltanto ad inizio o fine, lo stratagemma adottato per far scomparire all'attimo esatto le macchine evitate è stato quello di creare, oltre alle imageView degli autoveicoli, delle imageView coincidenti, con l' obiettivo di fare da 'target'. Le imageView che fanno da target hanno visibilità nulla. L' animazione di quest' ultime è rallentata rispetto alle imageView delle auto. In questo modo è possibile agire sulla visibilità delle auto durante gli eventi lanciati e catturati dai listener riferiti ai target. Di seguito si riporta l' esempio di tale implementazione adottato nella corsia centrale:

\begin{lstlisting}[language=java]

@Override
public void onAnimationEnd(Animation animation)
{
	globalData.setEnd2(true);
	t1.setText("FINITA ANIMAZIONE 2");
	if(globalData.isEnd2() && globalData.getAbsolutePosition()==2) {
		globalData.decreaseLife();
		textLifeLeft.setText("LIFE: " + globalData.getLife().toString());
		textLifeRight.setText("LIFE: " + globalData.getLife().toString());
		t2.setText("COLLISIONE SU 2");
		animationExplosionViewLeft = new AnimationExplosionView(activity.getApplicationContext());
		animationExplosionViewRight = new AnimationExplosionView(activity.getApplicationContext());
		animationExplosionViewLeft.setX((float) (displayWidth*0.135));
		animationExplosionViewLeft.setY((float) (displayHeight*0.25));
		animationExplosionViewRight.setX((float) (displayWidth*0.135));
		animationExplosionViewRight.setY((float) (displayHeight*0.25));
		relativeLayoutAnimationLeft.addView(animationExplosionViewLeft);
		relativeLayoutAnimationRight.addView(animationExplosionViewRight);
		animationEnemies.hideImage(enemyLeftLane2.get(0));
		animationEnemies.hideImage(enemyRightLane2.get(0));
		animationEnemies.hideImage(enemyLeftLane2.get(1));
		animationEnemies.hideImage(enemyRightLane2.get(1));
		animationEnemies.hideImage(enemyLeftLane2.get(2));
		animationEnemies.hideImage(enemyRightLane2.get(2));
		animationEnemies.hideImage(enemyLeftLane2.get(3));
		animationEnemies.hideImage(enemyRightLane2.get(3));
	}
	else {
		globalData.increaseScore();
		textScoreLeft.setText("SCORE: " + globalData.getScore().toString());
		textScoreRight.setText("SCORE: " + globalData.getScore().toString());
	}
}

\end{lstlisting}

Come si può vedere, si agisce sugli oggetti animationEnemies sfruttando l' evento onAnimationEnd(Animation animation) generato dal target. In particolare, oltre alla gestione della scomparsa dei veicoli si effettua un controllo sull' eventuale collisione con un auto nemica. Se lo scontro ha luogo, viene lanciata l' animazione dell'esplosione.

\newpage
\section{Gestione animazioni}\label{gestione_animazione}
La gestione delle animazione relative sia alle auto nemiche sia al paesaggio, è stata realizzata estendendo la classe Animation messa a disposizione da Android. In seguito verrà presentato l' esempio relativo alle auto nemiche. Per quanto rigurda il panorama, è stato applicato il medesimo principio.
Innanzitutto, per ogni corsia, è stato necessario creare un 'AnimationSet', ovvero un gruppo di animazioni riproducibile simultaneamente:

\begin{lstlisting}[language=java]

public AnimationSet animationSetLane1 = new AnimationSet(false);
public AnimationSet animationSetLane2 = new AnimationSet(false);
public AnimationSet animationSetLane3 = new AnimationSet(false);

\end{lstlisting}

Sono poi stati definititre metodi che implementano il comportamento della imageView delle auto, a seconda che si trovino nella corsia di destra, di sinistra o in quella centrale. Vediamone un esempio di funzionamento nella corsia di sinistra: 

\begin{lstlisting}[language=java]

public void animateFrontCarLane1(final ImageView ivLeft, final ImageView 	ivRight, int displayWidth, int displayHeight)
{
	TranslateAnimation TranslateAnimation1 = new TranslateAnimation(0, ((int) (Animation.RELATIVE_TO_SELF - (displayWidth * 0.04))),
	0,((int) (Animation.RELATIVE_TO_SELF + (displayHeight * 0.08))));
	ScaleAnimation ScaleAnimation1 = new ScaleAnimation(1, 5.2f,
	1, 5.2f, Animation.RELATIVE_TO_SELF, 0.9f, Animation.RELATIVE_TO_SELF, 0.5f);
	animationSetLane1.addAnimation(TranslateAnimation1);
	animationSetLane1.addAnimation(ScaleAnimation1);
	animationSetLane1.setDuration(4600);
	
	ivLeft.startAnimation(animationSetLane1);
	ivRight.startAnimation(animationSetLane1);
}

\end{lstlisting}

Come si può vedere dalla segnatura del medoto, vengono passati i due oggetti relativi alle imageView delle auto della corsia sinistra. In particolare 'ivLeft' si riferisce all' autoveicolo presente nel relativeLayout di sinistra, mentre 'ivRight' all' autoveicolo del relativeLayout destro. Per fare in modo che le animazioni avessero lo stesso comportamento su ogni dispositivo, si è deciso di applicare le trasalazioni e la scala operando sui valori di larghezza ed altezza del display. Per le traslazionivengono specificati come parametri i punti di partenza relativi alle coordinate 'x' ed 'y' dell'oggetto ed in seguito i punti di arrivo. Per la scala viene specificata la grandezza iniziale dell' imageView ed in seguito è indicato il valore moltiplicativo di scala sull'asse verticale ed orizzontale. Le singole animazioni vengono poi aggiunte all' animationSet tramite il metodo 'addAnimation'. Viene inoltre impostata la durata delle animazioni ed infine vengono fatte partire grazie al metodo 'startAnimation'.

\newpage
\section{Asynctask}\label{asynctask}
Per ottimizzare l'utilizzo di memoria del device da parte dell'applicazione sono stati utilizzate i task asincroni (Asynctask) per la gestione di tutta la parte grafica dinamica.\\ 
In molti framework di sviluppo con interfacce grafiche i task lunghi non devono essere eseguiti nel thread principale dell' applicazione. Infatti il thread principale è quello che si occupa di gestire gli eventi che arrivano dall' interfaccia (per esempio il click di un pulsante), se questo thread è già occupato a eseguire qualcos'altro l'effetto che si ottiene è quello di un ritardo di esecuzione (lag)\cite{asynktask}. 
\paragraph{I quattro passi:} un Asynktask in android si divide in quattro \virgolette{step}
\begin{enumerate}
	\item onPreExecute(), invocato sul thread della UI\footnote{User Interface} priva che il task venga eseguito. Qui viene solitamento messo il setup del task
	\item doInBackground(Params...), invocato nel background del thread, subito dopo onPreExecute(). Questo step è usato per eseguire computazioni in background che possono durare molto tempo.
	Il risultato della computazione deve essere tornato in questo step, e possono essere pubblicati grazie a publishProgress(Progress...). I valori sono passati all' UI thread nello step onProgressUpdate(Progress...).
	\item onProgressUpdate(Progress...), invocato nell' UI thread dopo aver chiamato publicProgress(Progress...). Questo metodo è usato per mostrare ogni progresso nella UI mentre in backgrond la computazione è ancora in esecuzione
	\item onPostExecute(Result), invocato dopo che la computazione in background è finita.\cite{aos}.
\end{enumerate}
%----------------------------------------------------------------------------------------
%	tool
%----------------------------------------------------------------------------------------
\chapter{Tool utilizzati}

In questo capitolo vengono spiegati i tool utilizzati durante lo sviluppo dell'applicazione, il tool principale, Android Studio, è descritto nella sezione (\ref{android_studio}), il tool per la sincronizzazione del lavoro da remoto, GitHub (\ref{github}) ed il tool per la gestione dei crash, crashlitics (\ref{crashlitics}).
\section{GitHub}\label{github}
Come repository del lavoro è stato utilizzato GitHub.\\
GitHub è un servizio web di hosting per lo sviluppo di progetti software, che usa il sistema di controllo di versione Git. Può essere utilizzato anche per la condivisione e la modifica di file di testo e documenti revisionabili.\\
GitHub offre diversi piani per repository privati sia a pagamento (utilizzato nel nostro caso, grazie all'account 3D4Amb), sia gratuiti, molto utilizzati per lo sviluppo di progetti open-source.\\
Grazie alla versione Desktop di GitHub, la gestione del lavoro e l' iterazione con il repository è resa ancora più semplificata. I comandi per l' aggiunta, la creazione e la clonazione di un repository direttamente accessibili dall'applicazione:
\newpage
\begin{figure}[h]
	\centering
	\includegraphics[width=\columnwidth]{immagini/git1.png}
	\caption{Pannello dei comandi GitHub Desktop}
	\label{Pannello dei comandi GitHub Desktop}
\end{figure}

Inoltre è possibile gestire i vari progetti e documenti mantenendo uno storico delle modifiche chiaro e tracciabile:

\begin{figure}[h]
	\centering
	\includegraphics[width=\columnwidth]{immagini/git2.png}
	\caption{Storico GitHub Desktop}
	\label{Storico GitHub Desktop}
\end{figure}

Tramite questo tool è quindi possibile creare un account, aggiungere un nuovo progetto ed inviare dati in pochi minuti. Se il progetto venisse inoltre reso open source, sarebbe possibile anche avere un' ampia comunità di sviluppatori che potrebbe osservare il progetto, biforcarlo ed dare un aiuto per migliorarlo.

\newpage
\section{Crashlitics}\label{crashlitics}
Per tenere traccia di eventuali problemi all' interno dell'applicazione è stato utilizzato Crashlitics\footnote{https://try.crashlytics.com/}.\\
Crashlitics è uno strumento per tenere traccia dei crash all'interno dell'applicazione, segnala in quale activity si è verificato il problema, genera statistihe di utilizzo degli utenti, e consente agli sviluppatori di gestire i bug (marcandoli come risolti o non risolti).\\
//TODO - aggiornare i dati prima di stampare la tesi (15/8/2015)\\
Da quando l'applicazione è stata rilasciata (11 Maggio 2015 per la versione 1.1)
Si sono verificati in totale 21 crash, molti dei quali(7) dovuti all'assenza di risposta da parte del server.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/daily_active_user}
	\caption{utenti attivi per giorno}
	\label{daily_active_user}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/daily_new_users}
	\caption{nuovi utenti ogni giorno}
	\label{daily_new_users}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/molthly_active_users}
	\caption{utenti attivi per mese}
	\label{monthly_active_user}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/crash_free_users}
	\caption{utenti che non hanno riscontrato crash}
	\label{crash_free_user}
\end{figure}


%----------------------------------------------------------------------------------------
%	PARTE IV
%----------------------------------------------------------------------------------------
\part{Valutazioni finali}
%----------------------------------------------------------------------------------------
%	social media
%----------------------------------------------------------------------------------------

\includepdf[pages={1,2,3,4}]{rehab2015_racecardboard.pdf} 
\chapter{Social media}\label{social_media}
\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/sito2}
	\caption{Car Racing Cardboard web site}
	\label{sito_web}
\end{figure}
La promozione dell'applicazione è stata effettuata con i mezzi che ad oggi sono più in voga, gli strumenti utilizzati sono stati Facebook\footnote{https://www.facebook.com/3D4Amb} e Google+\footnote{https://plus.google.com/u/1/110383688193490676162/posts}, è stato anche realizzato un sito internet\footnote{http://3d4amb.unibg.it/3dcar/cardboard\%20site/} (Figura \ref{sito_web}).\\
Il sito contiene informazioni sulla strumentazione necessaria per l'utilizzo dell'applicazione, rimanda alla pagina di Google Play per il download e continene anche una piccola guida utente.

\paragraph{Risultati promozione} sicuramente tale \virgolette{pubblicizzazione} ha infliuto nel numero di download dell'applicazione, possiamo notare un notevole picco dopo la data di rilascio: 

\begin{figure}[ht]
	\centering
	\includegraphics[width=\columnwidth]{immagini/stats_play_store}
	\caption{statistiche download da Google Play Store}
	\label{stats_play_store}
\end{figure}

%----------------------------------------------------------------------------------------
%   conclusioni
%----------------------------------------------------------------------------------------

\chapter{Conclusioni}

Lo scopo di questa applicazione è il trattamento dell'ambliopia, non è necessario avere a disposizione device costoso, al giorno d'oggi tutte le persone hanno uno smartphone e Goggole Cardboard è molto economico. Usando l'applicazione Car Racing Cardboard, le persone che soffrono di ambliopia possono migliorare il loro occhio pigro.\\
La tipologia di trattamento proposta da 3D4Amb, cerca di evitare i rischi della terapia occlusiva, ma può anche essere usata in parallelo con la terapia occlusiva\cite{rehab2015}. 
\paragraph{Certificazione contenuti:}
L'applicazione ha ricevuto delle certificazioni da Google Play Store:
\begin{figure}
	\centering
	\includegraphics[width=\columnwidth]{immagini/certifications.png}
	\caption{Classificazione contenuti}
	\label{classificaizone}
\end{figure}

\begin{itemize}
		\item Australian Classification Board (ACB) --	Australia
		\item Classificação Indicativa (ClassInd) --	Brazil
		\item Entertainment Software Rating Board (ESRB) --	North America
		\item Pan-European Game Information (PEGI) -- 	Europe
		\item Unterhaltungssoftware Selbstkontrolle (USK) -- Germany
		\item IARC Generic -- Rest of the world
		\item Google Play --South Korea	
\end{itemize}



\section{Paper}
Riguardo l'applicazione Car Racing Cardboard è stato steso un paper dal titolo: \textit{A low-cost virtual reality game for amblyopia rehabilitation}\\
//TODO descrizione paper?\\
Il paper è stato sottoposto alla commissione della conferenza rehab 2015\footnote{http://www.rehab-workshop.org/}, ed è stato accettato:
\begin{lstlisting}
Dear Angelo Gargantini, 

We have received the reviewers' reports on your paper 25 entitled 
A Low-cost Virtual Reality Game for Amblyopia Rehabilitation and I am glad to inform you that your paper has been classified as 
?Accepted?. 

For your guidance, reviewers' comments are appended below. I hope these comments 
can help you to improve the contribution. 

Please note that the deadline for the camera ready is the next September 13th, 2015

the process to register will be available next week in the workshop web page 
[http://www.rehab-workshop.org]

Thank you for your interest in the REHAB 2015 workshop. 

Yours sincerely, 
REHAB 2015 co-chairs
\end{lstlisting}
\section{Sviluppi futuri}
\begin{itemize}
	\item un famiglia di videogiochi mobile per il trattamento dell'ambliopia.
	Per come è stata pensata l'applicazione sarà sufficiente cambiare le immagini montate sugli \virgolette{scheletri} che gestiscono la parte grafica del gioco, per quanto riguarda la getione utenti e dati, le modifiche richieste saranno veramente minime
	\item una collaborazione attiva con i centri di ipovisione per raccogliere una maggior quantità di dati per migliorare l'efficacia dell'applicazione
	\item attuare i feedback provenienti dalla conferenza REHAB 2015, dove verrà presentata questa applicazione
\end{itemize}
%bibliografia
\bibliographystyle{abbrv}
\bibliography{tesi} 

\end{document}